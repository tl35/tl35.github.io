{"pages":[],"posts":[{"title":"vo dto entity 通过MapStruct拷贝","text":"在进行微服务开发时，经常需要进行entity和vo、dto之间的转换，之前一直使用BeanUtil.copyProperties(vo, entity)的方式，最近发现了一种新方法，即使用mapstruct，官网地址：MapStruct – Java bean mappings, the easy way! 现在idea已经有了MapStruct support for IntelliJ IDEA插件，配合lombok插件生成Getter和Setter可以非常方便的进行bean之间的拷贝。 详细使用方式和demo可以参见： mapstruct/mapstruct-examples: Examples for using MapStruct (github.com) 以下是Maven的的方式： 详细可见官方demo：mapstruct-examples/mapstruct-lombok at master · mapstruct/mapstruct-examples (github.com) 在pom.xml中添加 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;org.mapstruct.version&gt;1.5.1.Final&lt;/org.mapstruct.version&gt; &lt;org.projectlombok.version&gt;1.18.20&lt;/org.projectlombok.version&gt; &lt;lombok-mapstruct-binding.version&gt;0.2.0&lt;/lombok-mapstruct-binding.version&gt; &lt;/properties&gt;&lt;dependencies&gt; &lt;!-- lombok dependencies should not end up on classpath --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;${org.projectlombok.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct&lt;/artifactId&gt; &lt;version&gt;${org.mapstruct.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- IntelliJ pre 2018.1.1 requires the mapstruct processor to be present as provided dependency --&gt;&lt;!-- &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;${org.mapstruct.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;--&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;!-- See https://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html --&gt; &lt;!-- Classpath elements to supply as annotation processor path. If specified, the compiler --&gt; &lt;!-- will detect annotation processors only in those classpath elements. If omitted, the --&gt; &lt;!-- default classpath is used to detect annotation processors. The detection itself depends --&gt; &lt;!-- on the configuration of annotationProcessors. --&gt; &lt;!-- --&gt; &lt;!-- According to this documentation, the provided dependency processor is not considered! --&gt; &lt;annotationProcessorPaths&gt; &lt;path&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;${org.mapstruct.version}&lt;/version&gt; &lt;/path&gt; &lt;path&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;${org.projectlombok.version}&lt;/version&gt; &lt;/path&gt; &lt;path&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok-mapstruct-binding&lt;/artifactId&gt; &lt;version&gt;${lombok-mapstruct-binding.version}&lt;/version&gt; &lt;/path&gt; &lt;/annotationProcessorPaths&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt;&lt;/build&gt; 在代码中使用： 1234567891011/** * entity */@Data@EqualsAndHashCode(callSuper = true)@Accessors(chain = true)public class DataClusterEntity extends BaseEntity { private Long clusterId; private String clusterName; private String subType;} 12345678910/** * VO */@Data@Accessors(chain = true)public class Cluster { private Long clusterId; private String clusterName; private String subType;} 12345678910111213141516171819202122232425@Mapperpublic interface DataClusterConvert { DataClusterConvert INSTANCE = Mappers.getMapper(DataClusterConvert.class); /** * entity to vo * @param entity * @return */ Cluster toVo(DataClusterEntity entity); /** * to Vo of list * @param entity * @return */ List&lt;Cluster&gt; toVo(List&lt;DataClusterEntity&gt; entity); /** * to entity * @param vo * @return */ DataClusterEntity toEntity(Cluster vo);} 12345678// 使用方法DataClusterEntity entity = service.qryById(id);Cluster vo = DataClusterConvert.INSTANCE.toVo(entity);...List&lt;DataClusterEntity&gt; entity = service.list(query);List&lt;Cluster&gt; voList = DataClusterConvert.INSTANCE.toVo(entity); 查看编译后的class文件，可见会在DataClusterConvert同级package下生成一个DataClusterConvertImp.class文件，内容为 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class DataClusterConvertImpl implements DataClusterConvert { public DataClusterConvertImpl() { } public Cluster toVo(DataClusterEntity entity) { if (entity == null) { return null; } else { Cluster cluster = new Cluster(); cluster.setClusterId(entity.getClusterId()); cluster.setClusterName(entity.getClusterName()); cluster.setSubType(entity.getSubType()); return cluster; } } public List&lt;Cluster&gt; toVo(List&lt;DataClusterEntity&gt; entity) { if (entity == null) { return null; } else { List&lt;Cluster&gt; list = new ArrayList(entity.size()); Iterator var3 = entity.iterator(); while(var3.hasNext()) { DataClusterEntity dataClusterEntity = (DataClusterEntity)var3.next(); list.add(this.toVo(dataClusterEntity)); } return list; } } public DataClusterEntity toEntity(Cluster vo) { if (vo == null) { return null; } else { DataClusterEntity dataClusterEntity = new DataClusterEntity(); dataClusterEntity.setClusterId(vo.getClusterId()); dataClusterEntity.setClusterName(vo.getClusterName()); dataClusterEntity.setSubType(vo.getSubType()); return dataClusterEntity; } }}","link":"/2022/06/12/2022-06-11-java-bean-copy-mapstruct/"}],"tags":[],"categories":[]}